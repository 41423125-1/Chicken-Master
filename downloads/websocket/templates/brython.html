<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>Brython Robot Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Brython -->
    <script src="https://cdn.jsdelivr.net/npm/brython@3/brython.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/brython@3/brython_stdlib.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f4f4f4; }
        #brython_div1 { margin: 20px auto; text-align: center; }
        button { padding: 10px 20px; margin: 5px; font-size: 16px; }
        .status { margin-top: 10px; font-family: monospace; color: #333; }
    </style>
</head>
<body onload="brython()">

<div id="brython_div1"></div>
<div class="status" id="status">狀態：載入中...</div>

<script type="text/python">
from browser import document, html, timer, bind, websocket
import json

# ------------------------------------------------------------
# 常數
# ------------------------------------------------------------
CELL_SIZE      = 40
WALL_THICKNESS = 6
IMG_PATH       = "https://mde.tw/cp2025/reeborg/src/images/"

# ------------------------------------------------------------
# 1. World 類別
# ------------------------------------------------------------
class World:
    def __init__(self, width, height):
        self.width  = width
        self.height = height
        self.layers = self._create_layers()
        self._init_html()
        self._draw_grid()
        self._draw_walls()

    def _create_layers(self):
        return {
            "grid"   : html.CANVAS(width=self.width*CELL_SIZE, height=self.height*CELL_SIZE),
            "walls"  : html.CANVAS(width=self.width*CELL_SIZE, height=self.height*CELL_SIZE),
            "objects": html.CANVAS(width=self.width*CELL_SIZE, height=self.height*CELL_SIZE),
            "robots" : html.CANVAS(width=self.width*CELL_SIZE, height=self.height*CELL_SIZE),
        }

    def _init_html(self):
        container = html.DIV(style={"position":"relative","width":f"{self.width*CELL_SIZE}px","height":f"{self.height*CELL_SIZE}px","margin":"0 auto"})
        for z, canvas in enumerate(self.layers.values()):
            canvas.style = {"position":"absolute","top":"0","left":"0","zIndex":str(z)}
            container <= canvas

        btn_div = html.DIV(style={"marginTop":"15px","textAlign":"center"})
        self.move_btn = html.BUTTON("Move Forward (j)", Id="move_button", style={"padding":"10px 20px","fontSize":"16px"})
        self.turn_btn = html.BUTTON("Turn Left (i)", Id="turn_button", style={"padding":"10px 20px","fontSize":"16px"})
        btn_div <= self.move_btn + html.BR() + self.turn_btn

        document["brython_div1"].clear()
        document["brython_div1"] <= container
        document["brython_div1"] <= btn_div

    def _draw_grid(self):
        ctx = self.layers["grid"].getContext("2d")
        ctx.strokeStyle = "#cccccc"
        for i in range(self.width+1):
            ctx.beginPath(); ctx.moveTo(i*CELL_SIZE,0); ctx.lineTo(i*CELL_SIZE,self.height*CELL_SIZE); ctx.stroke()
        for j in range(self.height+1):
            ctx.beginPath(); ctx.moveTo(0,j*CELL_SIZE); ctx.lineTo(self.width*CELL_SIZE,j*CELL_SIZE); ctx.stroke()

    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0):
        img = html.IMG(src=src)
        def onload(_):
            px = x*CELL_SIZE + offset_x
            py = (self.height-1-y)*CELL_SIZE + offset_y
            ctx.drawImage(img, px, py, w, h)
        img.bind("load", onload)

    def _draw_walls(self):
        ctx = self.layers["walls"].getContext("2d")
        for x in range(self.width):
            self._draw_image(ctx, IMG_PATH+"north.png", x, self.height-1, CELL_SIZE, WALL_THICKNESS)
            self._draw_image(ctx, IMG_PATH+"north.png", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE-WALL_THICKNESS)
        for y in range(self.height):
            self._draw_image(ctx, IMG_PATH+"east.png", 0, y, WALL_THICKNESS, CELL_SIZE)
            self._draw_image(ctx, IMG_PATH+"east.png", self.width-1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE-WALL_THICKNESS)

# ------------------------------------------------------------
# 2. AnimatedRobot（連到 /ws）
# ------------------------------------------------------------
class AnimatedRobot:
    def __init__(self, world, x, y):
        self.world = world
        self.x = x-1; self.y = y-1
        self.facing = "E"
        self.facing_order = ["E","N","W","S"]
        self.robot_ctx = world.layers["robots"].getContext("2d")
        self.trace_ctx = world.layers["objects"].getContext("2d")
        self.queue = []; self.running = False
        self.images = {}
        for d in self.facing_order:
            img = html.IMG(src=IMG_PATH+f"blue_robot_{d.lower()}.png")
            self.images[d] = img
        self._draw_robot()

        # 連到 Flask 代理的 /ws
        self.ws_url = "/ws"
        self.ws = None
        self.connect_ws()

    def connect_ws(self):
        try:
            self.ws = websocket.WebSocket(self.ws_url)
            self.ws.bind("open",   self.on_ws_open)
            self.ws.bind("message",self.on_ws_message)
            self.ws.bind("error",  self.on_ws_error)
            self.ws.bind("close",  self.on_ws_close)
            self.update_status("連線中...")
        except Exception as e:
            print("連線失敗:", e)
            self.update_status("連線失敗，重試中...")
            timer.set_timeout(self.connect_ws, 1000)

    def on_ws_open(self, evt):
        self.update_status("WebSocket 已連線")

    def on_ws_message(self, evt):
        try:
            data = json.loads(evt.data)
            cmd = data.get("action")  # 關鍵：server 回傳 "action"
            print("Brython 收到:", cmd)
            self.update_status(f"收到指令: {cmd}")
            if cmd == "move":
                self.move(1)
            elif cmd == "turn_left":
                self.turn_left()
        except Exception as e:
            print("解析錯誤:", e)

    def on_ws_error(self, evt):
        self.update_status("連線錯誤")
        print("WebSocket 錯誤:", evt)

    def on_ws_close(self, evt):
        self.update_status("斷線，重試中...")
        print("斷線，重試...")
        timer.set_timeout(self.connect_ws, 1000)

    def update_status(self, msg):
        document["status"].text = f"狀態：{msg}"

    def _draw_robot(self):
        self.robot_ctx.clearRect(0,0,self.world.width*CELL_SIZE,self.world.height*CELL_SIZE)
        img = self.images[self.facing]
        px = self.x*CELL_SIZE
        py = (self.world.height-1-self.y)*CELL_SIZE
        if img.complete:
            self.robot_ctx.drawImage(img, px, py, CELL_SIZE, CELL_SIZE)
        else:
            img.bind("load", lambda _: self.robot_ctx.drawImage(img, px, py, CELL_SIZE, CELL_SIZE))

    def _draw_trace(self, fx, fy, tx, ty):
        ctx = self.trace_ctx
        ctx.strokeStyle = "#d33"; ctx.lineWidth = 2
        ctx.beginPath()
        ctx.moveTo(fx*CELL_SIZE+CELL_SIZE/2, (self.world.height-1-fy)*CELL_SIZE+CELL_SIZE/2)
        ctx.lineTo(tx*CELL_SIZE+CELL_SIZE/2, (self.world.height-1-ty)*CELL_SIZE+CELL_SIZE/2)
        ctx.stroke()

    def move(self, steps=1):
        def action(done):
            def step():
                nonlocal steps
                if steps == 0: done(); return
                fx, fy = self.x, self.y
                dx = dy = 0
                if self.facing == "E": dx = 1
                elif self.facing == "W": dx = -1
                elif self.facing == "N": dy = 1
                elif self.facing == "S": dy = -1
                nx, ny = self.x + dx, self.y + dy
                if 0 <= nx < self.world.width and 0 <= ny < self.world.height:
                    self.x, self.y = nx, ny
                    self._draw_trace(fx, fy, self.x, self.y)
                    self._draw_robot()
                    steps -= 1
                    timer.set_timeout(step, 200)
                else:
                    self.update_status("撞牆！")
                    done()
            step()
        self.queue.append(action)
        self._run_queue()

    def turn_left(self):
        def action(done):
            idx = self.facing_order.index(self.facing)
            self.facing = self.facing_order[(idx + 1) % 4]
            self._draw_robot()
            timer.set_timeout(done, 300)
        self.queue.append(action)
        self._run_queue()

    def _run_queue(self):
        if self.running or not self.queue: return
        self.running = True
        self.queue.pop(0)(lambda: self._done())

    def _done(self):
        self.running = False
        self._run_queue()

# ------------------------------------------------------------
# 3. 主程式
# ------------------------------------------------------------
w = World(10, 10)
r = AnimatedRobot(w, 1, 1)

# 按鈕控制
@bind("#move_button", "click")
def _move_click(evt):
    r.move(1)

@bind("#turn_button", "click")
def _turn_click(evt):
    r.turn_left()

# 初始移動
r.move(1)
</script>

</body>
</html>